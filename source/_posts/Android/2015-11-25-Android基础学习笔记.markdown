---
layout: post
title: "Android基础学习笔记"
date: 2015-11-25 16:22:32 +7012
comments: true
categories: Android
keywords: Android,Android基础,博客,AnnPeter's Blog
description: "Android基础学习笔记"

---

##ADB
```vim
$ adb start-server :启动adb进程
$ adb kill-server
$ adb install /home/annpeter/test.apk
$ adb uninstall 应用包名
$ adb devices :列出已经启动的Android设备
$ adb shell :进入安卓命令行
```

<!-- more -->

##电话拨号器
```vim
//需要添加权限:
<uses-permission android:name="android.permission.CALL_PHONE"/>
```

```java
String phone_num = ((EditText)findViewById(R.id.phone_num)).getText().toString();
Intent intent = new Intent();
intent.setAction(Intent.ACTION_CALL);
intent.setData(Uri.parse("tel:"+phone_num));
startActivity(intent);
```

##短息发送器
**Android下查看手机一些信息：**  \*\#\*\#4636\#\*\#\* 可以查看到IP地址，短息中心号码等信息

```java
String phone_num = ((EditText)findViewById(R.id.phone_num)).getText().toString();
String content = ((EditText)findViewById(R.id.content)).getText().toString();

SmsManager sm = SmsManager.getDefault();
sm.sendTextMessage(phone_num, null, content, null, null);
```

##布局介绍
###LinearLayout
* 有一个布局方向，水平或者竖直  &nbsp;**orientation**
* 在竖直布局下，左对齐、右对齐，水平居中生效  **Layout\_gravity**
* 在水平布局下，顶部对齐，底部对齐，竖直居中生效 **Layout\_gravity**
* 权重：按比例分配屏幕剩余的款对或者高度 &nbsp;**Layout\_weight**


###RelativeLayout
* 组建默认位置都是左上角，组建之间可以重叠
* 可以相对于父元素上下左右对齐，相对于父元素，水平居中、竖直居中、水平竖直居中	&nbsp;**layout\_alignParent&lowast;&lowast;**
* 可以相对于其他组建上下左右对齐
&nbsp;**layout\_align&lowast;&lowast;**

* 可以布局于其它组建的上方、下方、左方、右方 &nbsp;**layout_to&lowast;&lowast;Of**

###FrameLayout
* 组建默认位置都是左上角，组建之间可以重叠
* 可以设置上下左右对齐，水平竖直居中，设置方式和LinearLayout同

###TableLayout
* 每有一个TableRow表示一行，该子节点打每一个子节点都表示一列
* TabLayout的一级子节点默认宽都是match\_parent
* TableRow的子节点默认高度都是包裹wrap\_content
* TableLayout中制定拉伸列strechColumns，多个用逗号隔开
* layout\_column指定当前单元格列的位置
* layout\_span指定当前单元格占几列

###AbsoLutelayout
* 基本不会用到

##Android的存储
###内部存储空间
* RAM内存：运行内存，相当于电脑多内存
* ROM内存：存储内存，相当于电脑多硬盘

###外部存储空间
* SD卡：相当于电脑的移动硬盘


###Android写文件操作
/data/data/\* &nbsp;下文件操作不需要Android文件读写权限，该路径下的访问权限只有本应用程序有，其它程序不可访问

```java
//File file = new File("/data/data/com.example.neibucuncu/name.txt");
File file = new File(getFilesDir(), "name.txt");
FileOutputStream fos = new FileOutputStream(file);
fos.write(editText.getText().toString().getBytes());
fos.close();
```

###Android读文件操作
```java
//File file = new File("/data/data/com.example.neibucuncu/name.txt");
File file = new File(getFilesDir(), "name.txt");
if(file.exists()){
	try {
		FileInputStream fis = new FileInputStream(file);
		//把字节流转为字符流
		BufferedReader br = new BufferedReader(new InputStreamReader(fis));
		String str = "";
		String line;
		while( (line = br.readLine()) != null){
			str += line;
		}

		//当我把间隔符号换成$$, split不能分开。。。
		String[] strArr = str.split("##");
		((EditText)findViewById(R.id.name)).setText(strArr[0]);
		((EditText)findViewById(R.id.passwd)).setText(strArr[1]);

	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
```


###使用路径API获取内部存储路径
```java
File getFilesDir();		//该路径只允许本程序访问，位于/data/data/应用包名/files下
File getCacheDir();		//和上面一样只是这个API获取出来位于/data/data/应用包名/Cache下
						//当系统内部存储不足时，cache中的文件可能会被删除，可以设置该文件
						//中文件的阀值
```

###Android外部存储空间
```java
Environment.getExternalStorageState(); 	//MEDIA_UNKNOWN:不能识别SD卡
										//MEDIA_REMOVED:没有SD卡
										//MEDIA_UNMOUNTED:SD卡存在但是没有挂载
										//MEDIA_CHECKING:SD卡正在准备
										//MEDIA_MOUNTED:SD卡已经挂载可用
Environment.getExternalStorageDirectory(); //获取SD卡路径

//获取SD卡剩余空间－－查看Android源码
File path = Environment.getExternalStorageDirectory();
StatFs stat = new StatFs(path.getPath());
long blockSize = stat.getBlockSize();
long totalBlocks = stat.getBlockCount();
long avialableBlocks = stat.getAvailableBlocks();

String size = Formatter.formatFileSize(this, avialableBlocks * blockSize);
```

###获取当前系统的等级
```java
Build.VERSION.SDK_INT 	//当前系统等级
Build.VERSION_CODES.**	//安卓SDK等级代号
```

###创建特定访问权限的文件
```java
//在内部存储中创建文件，默认路径为 /data/data/应用包名/files
//MODE_PRIVATE本程序可以访问
//MODE_WORLD_WRITEABLE全局可写
FileOutputStream fos = openFileOutput("name.txt", MODE_**);
fos.write("AnnPeter".getBytes());
fos.close();
```

###SharedPreference
```java
//路径为 /data/data/应用包名/shared_prefs/info.xml
SharedPreference sp = getSharedPreference("info", MODE_PRIVATE);
//拿到sp的编辑器
Editor ed = sp.edit();
//以键值对方式写入
ed.putString("name","AnnPeter");
ed.commit();

//读取
sp.getString("name", "defaultString");	//第二个参数为，获取失败时的字符串
```


##XML短信备份
```java
//模拟创建短信内容
List<Message> smsList = new ArrayList<Message>();
for(int i = 0; i < 100; i++){
	Message message = new Message("AnnPeter is "+ i, "2015-01-"+i, "1", "123456"+i);
	smsList.add(message);
}

//用StringBuffer方式拼接XML，下面还提供了XML序列化器的方式
StringBuffer sb = new StringBuffer();
//XML头的信息的顺序必须如此先version再encoding再standalone
//XML下面子能有一个子元素
sb.append("<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n");
sb.append("<message>\n");
for(int i = 0; i < smsList.size(); i++){
	Message message = smsList.get(i);
	sb.append("<sms>\n");
	sb.append("\t<body>"+message.getBody()+"</body>\n");
	sb.append("\t<data>"+message.getData()+"</data>\n");
	sb.append("\t<type>"+message.getType()+"</type>\n");
	sb.append("\t<adress>"+message.getAdress()+"</adress>\n");
	sb.append("</sms>\n");
}
sb.append("</message>\n");

File file = Environment.getExternalStorageDirectory();
//Android目录不存在不会创建目录，但是文件不存在会创建文件
file = new File(file, "/message.xml");
FileOutputStream fos = null;
try {
	fos = new FileOutputStream(file);
	fos.write(sb.toString().getBytes());
	fos.close();
} catch (FileNotFoundException e) {
	e.printStackTrace();
} catch (IOException e) {
	e.printStackTrace();
}
```

###XML序列化器 **用序列化生成器可以自动转义掉节点内部非法的字符**

```java
List<Message> smsList = new ArrayList<Message>();
for(int i = 0; i < 100; i++){
	Message message = new Message("AnnPeter is "+ i, "2015-01-"+i, "1", "123456"+i);
	smsList.add(message);
}
//拿到序列化生成器对象
XmlSerializer xmlSerializer = Xml.newSerializer();
File file = new File(Environment.getExternalStorageDirectory().getPath()+"/message2.xml");
FileOutputStream fos = null;
try {
	fos = new FileOutputStream(file);
	xmlSerializer.setOutput(fos, "utf-8");//这里的utf-8指的是用什么编码保存该XML文件
	xmlSerializer.startDocument("utf-8", true);//这里的utf-8指的是XML文件头上的encoding

	xmlSerializer.startTag(null, "message");
	for(int i = 0; i < smsList.size(); i++){
		xmlSerializer.startTag(null, "sms");

		xmlSerializer.startTag(null, "body");
		xmlSerializer.text(smsList.get(i).getBody());
		xmlSerializer.endTag(null, "body");

		xmlSerializer.startTag(null, "data");
		xmlSerializer.text(smsList.get(i).getData());
		xmlSerializer.endTag(null, "data");

		xmlSerializer.startTag(null, "adress");
		xmlSerializer.text(smsList.get(i).getAdress());
		xmlSerializer.endTag(null, "adress");

		xmlSerializer.startTag(null, "type");
		xmlSerializer.text(smsList.get(i).getType());
		xmlSerializer.endTag(null, "type");

		xmlSerializer.endTag(null, "sms");
	}
	xmlSerializer.endTag(null, "message");

	xmlSerializer.endDocument();//告诉序列化生成器，XML生成完毕
} catch (Exception e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}
```

###PULL解析XML文件

```java
//获取src文件夹下的资源文件
InputStream is = getClassLoader().getResourceAsStream("message.xml");

//拿到PULL解析器对象
XmlPullParser xpp = Xml.newPullParser();
try {
	xpp.setInput(is, "utf-8");

	//获取当前节点的事件类型，通过对事件类型的判断，我们可以知道当前节点是什么节点，从而确定应该执行什么样的操作
	int type = xpp.getEventType();

	Message message = null;
	while(type != XmlPullParser.END_DOCUMENT){
		String name = xpp.getName();

		switch (type) {
			case XmlPullParser.START_TAG:
				if("message".equals(name)){
					messageList = new ArrayList<Message>();
				}else if("sms".equals(xpp.getName())){
					message = new Message();
				}else if("body".equals(name)){
					message.setBody(xpp.nextText());
				}else if("adress".equals(name)){
					message.setAdress(xpp.nextText());
				}else if("type".equals(name)){
					message.setType(xpp.nextText());
				}else if("data".equals(name)){
					message.setData(xpp.nextText());
				}
				break;
			case XmlPullParser.END_TAG:
				if("sms".equals(name)){
					messageList.add(message);
				}
				break;
		}

		type = xpp.next();
	}

	for (Message ms : messageList) {
		System.out.println(ms.toString());
	}
} catch (Exception e) {
	e.printStackTrace();
}
```

##测试

###按岗位划分

* 黒盒测试：测试逻辑业务
* 白盒测试：测试逻辑方法

###按测试粒度分
* 方法测试： function test
* 单元测试： unit test
* 集成测试： integration test
* 系统测试： system test

###按测试的暴力程度分
* 冒烟测试： smock test
* 压力测试： pressure test

###单元测试 junit
* 测试类继承AndroidTestCase
* 在AndroidManifest.xml文件中指定指令集

```xml
//该条配置和application同级
<instrumentation
	   	android:name="android.test.InstrumentationTestRunner"
	   	//指定该测试框架要测试哪一个项目
	   	android:targetPackage="com.example.junit">
</instrumentation>

//该条配置和activity同级
<uses-library android:name="android.test.runner"/>
```

###断言：用来检测实际值与期望值是否一样
```java
assertEquals(arg1, arg2);	//arg1表示期望值，arg2表示实际值
```


##数据库SQLite
```java
//构建数据库管理类，继承自SQLiteOpenHelper，实现父类的抽象方法

public class MyOpenHelper  extends SQLiteOpenHelper{

	public MyOpenHelper(Context context, String name, CursorFactory factory, int version) {
		super(context, name, factory, version);

	}

	@Override
	public void onCreate(SQLiteDatabase db) {
		db.execSQL("create table person(_id integer primary key autoincrement,
						name char(20), salary char(20), phone char(11));");

	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

	}

}


//getContext():junit测试框架获取虚拟上下文， 如果要使mHelper称为全局变量，则他不能在定义时初始化，
//全局变量的初始化时测试框架还没有初始化完毕，虚拟上下文对象也没有初始化成功，getContext()
//不能获取到实际对象，对于全局变量的初始化，可以重写父类的setUp()方法来初始化。
//setUp()在测试框架初始化完成后调用，在测试方法调用前调用，还有一个父类的tearDown()方法，
//在测试方法调用后调用，可以用于测试完成后的操作

MyOpenHelper mHelper = new MyOpenHelper(getContext(), "people.db", null, 1);
//如果数据库不存在，先创建数据库，再获取可读可写数据库对象；如果数据库存在，直接打开
SQLiteDatabase db = mHelper.getWritableDatabase();
//如果存储空间（内部存储，所以备份文件一般不采用数据库保存）满了，那么返回只读数据库对象

//执行SQL语句－－用获取到的db对象，调用
db.execSQL();方法即可,可用于数据库创建，表创建，增加、修改、删除；db.rawQuery();用于查询
db.execSQL("insert into person(name, phone, salary) values(?, ?, ?)",
			new Object[]{"AnnPeter", "12312341234", "60000"});

//Curosr中，通过列名获取值
while(curosr.moveToNext()){//cursor初始化指向－1条记录
	String name = cursor.getString(cursor.getColumnIndex("name"));
}
db.close();	//关闭数据库连接


//使用API来增删改查
//插入，把待插入的数据封装至ContentValues对象中
//ContentValue使用完后最好clear()一下，否则可能下次使用时，插入上次相同的记录会出现两个
ContentValues values = new ContentValues();
values.put("name", "AnnPeter");
values.put("phone", "12312341234");
db.insert("person", null, values);
```

###SQLite事务
> 保证所有SQL语句要么一起成功，要么一起失败。

```java
try{
	db.beginTransaction();

	//数据库操作

	//设置 表明事务执行成功
	db.setTransactionSuccessful();
}catch (Exception e) {
	e.printStackTrace();
}finallly{
	//关闭事务，同时提交, 如果执行此代码时，已经表明事务执行成功，则此次SQL语句生效，反之自动执行事务回滚
	db.endTransation();
}
```


##ListView
**当ListView中有Button，ImageButton， CheckBox等会强制获取焦点的View，此时，ListView的Item无法获取焦点，从而无法被点击。－－－－解决方法：给Item的根布局增加一下属性：android:descendantFocusability="blocksDescendants"**

```java
ListView lv = (ListView) findViewById(R.id.listView);
lv.setAdapter(new MyAdapter());


class MyAdapter extends BaseAdapter{

	//系统调用，用来获知集合中有多少条元素
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return smsList.size();
	}

	//由系统调用，获取一个view对象，作为ListView的条目
	//position:本次getView方法调用所返回的View对象，在ListView中处于第几个条目
	//ListView在不可见时，可能会被系统销毁，以节约内存，取决于当前内存状态
	//convertView缓存的是ListView的条目，缓存条目的个数是一屏能显示的最多条目的个数，
	//所以在利用缓存的时候，条目里面显示的内容需要我们重新填充,之所以这么做是因为
	//在使用布局文件填充view对象时，inflater方法比较耗费资源，容易内存溢出
	@Override
	public View getView(int position, View convertView, ViewGroup parent) {
		TextView tv = new TextView(MainActivity.this);
		tv.setText(smsList.get(position).getBody());
		tv.setTextSize(18);
		return tv;
	}

	@Override
	public Object getItem(int position) {
		return null;
	}

	@Override
	public long getItemId(int position) {
		return 0;
	}
}
```

###把布局文件填充成一个View对象
```java
//把布局文件填充成一个View对象
//方法一
View v0 = View.inflate(MainActivity.this, R.layout.item, null);

//通过资源id查找组件，注意调用的是View对象的findViewById
TextView tv = (TextView) v0.findViewById(R.id.name);
tv.setText(smsList.get(position).getBody());

//方法二
LayoutInflater inflater = LayoutInflater.from(MainActivity.this);
View v1 = inflater.inflate(R.layout.item, null);

//方法三
LayoutInflater inflater2 = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);
View v2 = inflater.inflate(R.layout.item, null);
```

###ArrayAdapter
```java
String[] strArr = new String[]{
	"Ann",
	"Peter",
	"AnnPeter"
};

ListView lv = (ListView) findViewById(R.id.listView);
//ArrayAdapter只能处理一种类型的数据
ArrayAdapter arrayAdapter = new ArrayAdapter<String>(this, R.layout.item,
										R.id.textView, strArr);
lv.setAdapter(arrayAdapter);
arrayAdapter.notifyDataSetChanged(); //当strArr发生改变，动态刷新ListView
```

###SimpleAdapter
```java
ListView lv = (ListView) findViewById(R.id.listView);

List<Map<String, Object>> data = new ArrayList<Map<String,Object>>();

Map<String, Object> map1 = new HashMap<String, Object>();
map1.put("photo", R.drawable.img01);
map1.put("name", "Ann");
data.add(map1);
Map<String, Object> map2 = new HashMap<String, Object>();
map2.put("photo", R.drawable.img02);
map2.put("name", "Peter");
data.add(map2);
Map<String, Object> map3 = new HashMap<String, Object>();
map3.put("photo", R.drawable.img03);
map3.put("name", "AnnPeter");
data.add(map3);

lv.setAdapter(new SimpleAdapter(this, data, R.layout.item, new String[]{"photo", "name"}, 
								new int[]{R.id.photo, R.id.name}));
```



##对话框
###Dialog
```java
//构建一个AlertDialog的创建器
AlertDialog.Builder builder = new Builder(this);
builder.setTitle("Title");
builder.setIcon(R.drawable.abc_ab_share_pack_mtrl_alpha);
builder.setMessage("Content");
builder.setPositiveButton("确定", new OnClickListener() {
	@Override
	public void onClick(DialogInterface dialog, int which) {
		Toast.makeText(MainActivity.this, "确定", Toast.LENGTH_SHORT).show();
	}
});

builder.setNegativeButton("取消", new OnClickListener() {
	@Override
	public void onClick(DialogInterface dialog, int which) {
		Toast.makeText(MainActivity.this, "取消", Toast.LENGTH_SHORT).show();
	}
});

//创建一个AlertDialog
AlertDialog dialog = builder.create();
dialog.show();
```

###单选对话框
```java
//构建一个AlertDialog的创建器
AlertDialog.Builder builder = new Builder(this);
builder.setTitle("Title");
builder.setIcon(R.drawable.abc_ab_share_pack_mtrl_alpha);
builder.setSingleChoiceItems(new String[]{"男", "女"}, 0, new OnClickListener() {

	@Override
	public void onClick(DialogInterface dialog, int which) {
		Toast.makeText(MainActivity.this, "您选择的是"+which, Toast.LENGTH_SHORT).show();
		dialog.dismiss();	//选择完后自动消失
	}
});

//创建一个AlertDialog
AlertDialog dialog = builder.create();
dialog.show();
```

###多选对话框
```java
AlertDialog.Builder builder = new Builder(this);
builder.setTitle("Title");
builder.setIcon(R.drawable.abc_ab_share_pack_mtrl_alpha);

builder.setMultiChoiceItems(new String[]{"Ann", "Peter", "AnnPeter"},
				new boolean[]{true, true, true},
				new OnMultiChoiceClickListener(){
	@Override
	public void onClick(DialogInterface dialog, int which, boolean isChecked) {

	}
});

builder.setPositiveButton("确定", new OnClickListener() {
	@Override
	public void onClick(DialogInterface dialog, int which) {
		Toast.makeText(MainActivity.this, "确定", Toast.LENGTH_SHORT).show();
	}
});

builder.setNegativeButton("取消", new OnClickListener() {
	@Override
	public void onClick(DialogInterface dialog, int which) {
		Toast.makeText(MainActivity.this, "取消", Toast.LENGTH_SHORT).show();
	}
});

//创建一个AlertDialog
AlertDialog dialog = builder.create();
dialog.show();
```



##网络编程
###主线程阻塞
* UI停止刷新，应用无法响应用户的操作
* 耗时操作不应该在主线程中执行
* ANR（application not respond）异常，主线程阻塞时间过长就会抛出ANR异常
* 主线程又称为UI线程，因为只有在主线程中，才能刷新UI

###消息队列
* 主线程中有一个message queue（消息队列，用于保存消息） 和 looper（消息轮询器，用于检测消息队列是否有消息），在主线程创建时，系统自动创建这两个对象
* Handler（消息处理器，处理消息 handleMessage()）， 一旦消息队列有消息，主线程就会自动调用handleMessage()方法处理，程序员在需要使用时手动创建
* 子线程使用Handler对象来向主线程的消息队列发送消息，触发主线程调用handleMessage刷新UI即可。

###网络图片查看器
```java
static MyHandler handler = null;
handler = new MyHandler(this);

//1.Android建议我们Handler最好是static的，以断开Handler和外部class的联系，让内部类和外部类不产生任何
//联系就是static class的目的，防止GC时因为handle有引用导致，activity不能被回收，循环泄漏

//2.我们不需要在Activity中通过申明大量的static 变量来提供给handler 使用（这样的代码不仅难看而且设计很
//不合理）因为在MyHandler中设计一个mActivity的弱引用所以，我们可以调用mActivity的任何public函数和变量。

//当Activity被finish()掉，这个Message持有一个对Handler的引用，Handler也会持有一个对于外部类
//（SampleActivity）的隐式引用，这些引用在Message被执行前将一直保持，这样会保证Activity的上下文不
//被垃圾回收机制回收，同时也会泄露应用程序的资源（views and resources）。

static class MyHandler extends Handler{
	WeakReference mActivity =  null;
	public MyHandler(Activity activity) {
		mActivity = new WeakReference<Activity>(activity);
	}

	@Override
	public void handleMessage(android.os.Message msg) {
		Activity activity = (Activity) mActivity.get();
		//处理消息时，要知道是成功的消息还是失败的消息
		switch (msg.what) {
		case 1:
			Bitmap bitmap = (Bitmap) msg.obj;
			ImageView iv = (ImageView) activity.findViewById(R.id.imageView1);
			iv.setImageBitmap(bitmap);
			break;
		case 0:
			Toast.makeText(activity, "请求失败", Toast.LENGTH_SHORT).show();
			break;
		default:
			break;
		}
	};
}


//如果有缓存则从缓存中读取
File file = new File(getCacheDir(), "img01.jpg");
if(file.exists()){
	FileInputStream fis = new FileInputStream(file);

	Bitmap bitmap = BitmapFactory.decodeStream(fis);
	ImageView iv = (ImageView)findViewById(R.id.imageView1);
	iv.setImageBitmap(bitmap);
}else{
	Thread thread = new Thread(){
		@Override
		public void run() {
			super.run();
			//下载图片
			//1.确定网址
			String path = "http://10.0.2.2/imgs/img01.jpg";
			try {
				//2.把网址封装成一个URL对象
				URL url = new URL(path);
				//3.获取客户端和服务端的连接，此时连接还没有建立
				HttpURLConnection conn = (HttpURLConnection) url.openConnection();

				//4.对连接进行初始化
				//4.1设置请求方法，注意大写
				conn.setRequestMethod("GET");
				//4.2设置连接超时
				conn.setConnectTimeout(5000);
				//4.3设置读取超时
				conn.setReadTimeout(5000);

				//5.发送请求，与服务器建立连接
				conn.connect();

				//如果响应吗为200，表明请求成功，服务器返回数据流
				if(conn.getResponseCode() == 200){
					InputStream is = conn.getInputStream();

					//读取出流里的数据，并构造成位图对象
					//Bitmap bitmap = BitmapFactory.decodeStream(is);

					File file = new File(getCacheDir(), "img01.jpg");

					ByteArrayOutputStream baos = new ByteArrayOutputStream();
					byte[] buffer = new byte[1024];

					while(is.read(buffer) != -1){
						baos.write(buffer);
					}
					byte[] data = baos.toByteArray();
					baos.close();

					//写入缓存
					FileOutputStream fos = new FileOutputStream(file);
					fos.write(data);
					fos.close();

					//BitmapFactory.decodeFile(pathName);用 BitmapFactory.decodeStream()
					//这个方法，会出现概率性的解析失败的异常
					Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);

					//Message最好不要自己new，使用Handler中的obtainMessage()获取，obtainMessage()
					//会先检查消息缓冲池中是否有消息， 如果有，返回一个无用消息, 这样可以节约内存
					Message msg = new Message();
					msg.obj = bitmap;
					msg.what = 1;
					handler.sendMessage(msg);
				}else{
					Message msg = handler.obtainMessage();
					msg.what = 0;
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	};
	thread.start();
}
thread.start();
```



##对ListView的进一步优化
```java
@Override
public View getView(int position, View convertView, ViewGroup parent) {
	View view = null;
	ViewHolder mHolder = null;

	NEWS news = newsList.get(position);

	if(convertView == null){
		view = View.inflate(activity, R.layout.item, null);

		mHolder = new ViewHolder();
		mHolder.title =  (TextView)view.findViewById(R.id.title);
		mHolder.body = (TextView)view.findViewById(R.id.body);
		mHolder.read = (TextView)view.findViewById(R.id.readNum);
		mHolder.img = (SmartImageView)view.findViewById(R.id.item_img);

		//以前只是通过convertView将ListView中的每个子条目缓存起来，
		//现在通过封装一个ViewHolder对象，将每个字条目内部的对象全部缓存起来，
		//提高了效率
		view.setTag(mHolder);
	}else{
		view = convertView;
		mHolder = (ViewHolder) convertView.getTag();
	}

	mHolder.img.setImageUrl(news.getInfoImgUrl());
	mHolder.title.setText(news.getTitle());
	mHolder.body.setText(news.getBody());
	mHolder.read.setText(""+news.getRead()+"条阅读量");
	return view;
}

class ViewHolder{
	SmartImageView img;
	TextView title;
	TextView body;
	TextView read;
}
```

##GET、POST提交数据
*  使用GET方式提交数据时，如果URL地址中包含中文，注意使用URLEncoder转换

```java
URL url = new URL(path);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("POST");
conn.setConnectTimeout(5000);
conn.setReadTimeout(5000);

//拼接出要提交的数据的字符串
String text = "name=" + URLEncoder.encode("AnnPeter", "utf-8")+"&pass="+"123";

//添加POST请求的两行属性
conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
conn.setRequestProperty("Content-Length", ""+text.length());

//设置RANGE属性，实现分块下载，多线程下载
//conn.setRequestProperty("RANGE", "bytes="+startIndex+"-"+endIndex);

//设置打开输出流，默认关闭
conn.setDoOutput(true);

//拿到输出流
OutputStream os = conn.getOutputStream();

os.write(text.getBytes());

conn.connect();

if(conn.getResponseCode() == 200){
	InputStream is = conn.getInputStream();
}
```




##Activity
####Activity的跳转

* Android的每一个Activity都需要在AndridManifest.xml文件中注册
* 主界面需要在Activity中添加子节点
```xml
<intent-filter>
	<action android:name="android.intent.action.MAIN"/>
	<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
```

* 安卓可以有多个入口，只要将上面的节点添加到Acitity中，就会在安卓的桌面出现一个快捷图标， 每个Activity图标就是桌面快捷方式的图标
* 每个Activity都有自己的Label，没有Label的默认使用Application的Label

```java
//显示跳转，直接指定目标Activity的类名
Intent intent = new Intent();
intent.setClass(this, SecondActivity.class);

//隐式跳转
//Intent.ACTION_CALL 打电话应用
//Intent.ACTION_VIEW 浏览器
intent.setAction(Intent.ACTION_CALL);
intent.setData(Uri.parse("tel:110"));

//显示跳转
intent.setClass("com.android.dialer", "com.android.dialer.DialtactsActivity");
intent.putExtra(arg1, arg2);	//传递参数
//传递数据还可以把所有数据封装至一个Bundle对象中
Bundle bundle = new Bundle();
bundle.putString("name", "AnnPeter");
intent.putExtras(bundle);


//隐式跳转
//指定一个activity可以隐式跳转，需要在AndroidManifest.xml，activity子节点下添加属性
//有动作的activity才可以跳转
	<intent-filter>
		<action android:name="cn.annpeter.Activity"/> //name随便写,即设置的是intent.setAction()
		<category android:name="android.intent.category.DEFAULT"/>
		//<data android:scheme="AnnPeter" android:mimeType="text/username"/>
	</intent-filter>
intent.setAction("cn.annpeter.Activity");
//Intent.CATEGORY_DEFAULT 等价于 "android.intent.category.DEFAULT"
//而且系统会默认添加category，所以当category设置为"android.intent.category.DEFAULT"时，
//下面一行代码可以不用写
intent.addCategory(Intent.CATEGORY_DEFAULT);
//如果要传输data，AndroidManifest.xml文件中本activity的intent-filter必须有一个<data />子节点
//当data类型为scheme时AnnPeter必须是匹配的才行
intent.setData(Uri.parse("AnnPeter:要传输的内容"));

//接收方接收Intent和参数
Intent intent = getIntent();
Uri uri = intent.getData();	//获取参数

```

####总结：
* 想要实现隐式跳转，inter-filter的设置和在代码中调用时的条目必须一一匹配
* 一个activity可以设置多个inter-filter，要想成功跳转，只需完全匹配其中一个即可
* 一个inter-filter中可以有多个anction，data，只需匹配一组即可
* data可以指定mimeType标记data的类型，方便其它调用者查看，或接收页面识别使用
* 如果data和mineType同时存在，则不能调用intent.setData()和intent.setType()，他们两个不能共存；而要使用intent.setDataAndType()
* 如果是启动同一个应用中的activity，则一般用显示意图，如果是启动不同应用中的activity则一般用隐式； 全部都使用隐式是可以的，但显示跳转查找activity的速度比隐式的快（隐式需要在系统中的所有APP中的AndroidManifest.xml中查找inter-filter）；全部用显示，如果系统中有多个浏览器，则不会弹出选框让用户选择，隐式跳转如果有多个同类应用（inter-filter中的action是一样的），则会弹出选框选择

###Activity生命周期
* onCreate: activity被创建时调用
* onStart: activity能被用户看见，但是没有获得焦点
* onResume: activity获得焦点，此时activity称为前台activity
* onPause: activity失去焦点，但是依然可见
* onStop: activity不可见，此时Activity称为后台activity
* onDestroy: activity被销毁

当两个页面间使用startActivityForResult(intent, requestCode);那么在页面返回的时候自动调用回调函数protected void onActivityResult(int requestCode, int resultCode, Intent data);

![Activity生命周期图](/upload/2015/OCT/11/imgs/1444540809.png)

###内存不足时
* 内存不足时，系统会优先杀死后台activity所在的进程，都杀光了，如果内存还是不够用，那么就会杀死暂停状态的activity所在的进程，如果还是不够，有可能杀死前台进程
* 如果有多个后台进程，在选择杀死的目标的时候，采用最近最少使用的算法（LRU）

###Activity启动模式
>在AndroidManifest.xml的activity子节点下设置android:launchMode
>－standard 标准模式，默认
>－singleTop 不能在本Activity启动本Activity
>－singleTask 如果该activity没有启动过，则会启动并跳转至该activity，即该activity出现在栈顶，如果该activity已经启动过，但不在栈顶，那么再次启动时，会返回该activity，即把该activity上方所有activity全部销毁。(在任务栈中，永远只有一个该activity的实例)
>－singleInstance 该activity启动时，会在一个新的任务栈中启动，并且只会启动一次，以后再次启动该activity，其实只是把该activity所有的任务栈移动至前台（非单例模式的activity如果在10个应用中启动，那么就会有10个该实例，单例模式的activity，**内存**中永远只有一个，10个应用启动单例模式的activity，都只是把该activity所在的任务栈移动至前台）



##Android横竖屏切换
###模拟器快捷键 Ctrl ＋ F11（Ctrl键必须是左Ctrl）

* 在进行横竖屏切换时，默认Activity会被销毁然后重建， 若不想重建可以在AndroidManifest.xml中的activity中加入 android:configChanges="orientation|keyboardHidden|screenSize"
* 写死横竖屏
	>横屏：android:screenOrientation="landscape"<br>
	>或者：setRequestedOrientation(ActivityInfo.SCREEN\_ORIENTATION\_LANDSCAPE);<br>
	><br>
	>竖屏：android:screenOrientation="portrait"<br>
	>或者：setRequestedOrientation(ActivityInfo.SCREEN\_ORIENTATION\_PORTRAIT);<br>



##广播接收者（四大组件之一）
* 现实生活中：电台要发布消息，通过广播把消息广播出去，使用收音机就可以收听广播，得知这条消息
* Android中：系统在运行过程中，会产生很多事件，那么某些事件产生时，比如：电量改变、收发短信、拨打电话、屏幕解锁、开机、系统会发送广播，只要应用程序接受到这条广播，就知道系统发生了相应点事件，从而执行相应的代码。使用**广播接收者**，就可以收听广播
* 在Android中，每次广播消息到来时都会创建BroadcastReceiver实例并执行onReceive() 方法， onReceive() 方法执行完后，BroadcastReceiver 的实例就会被销毁。当onReceive() 方法在10秒内没有执行完毕，Android会认为该程序无响应。所以在BroadcastReceiver里不能做一些比较耗时的操作，否侧会弹出ANR（Application No Response）的对话框。如果需要完成一项比较耗时的工作，应该通过发送Intent给Service，由Service来完成。这里不能使用子线程来解决，因为BroadcastReceiver的生命周期很短，子线程可能还没有结束BroadcastReceiver就先结束了。BroadcastReceiver一旦结束，此时BroadcastReceiver的所在进程很容易在系统需要内存时被优先杀死，因为它属于空进程（没有任何活动组件的进程）。如果它的宿主进程被杀死，那么正在工作的子线程也会被杀死。所以采用子线程来解决是不可靠的。

###创建广播接收者
* 定义java类继承自BroadcastReceiver
* 在清单文件中定义receiver节点，定义name属性，指定广播接收者java类的全类名
* 指定要接收广播的类型，在intent-filter的节点中，指定action子节点，action的值必须跟要接受的广播中的action匹配
	>打电话广播：&lt;action android:name="android.intent.action.NEW\_OUTGOING_CALL"/><br>
	>短信广播：	&lt;action android:name="android.provider.Telephony.SMS\_RECEIVED" /><br>

* 即便广播接收者所在进程已经被关闭（被系统关闭），当系统发出的广播的action和该广播接收者的action匹配，系统会启动该广播接收者所在的进程，并发送广播至该进程（这就可以不必一直开着广播接收者进程，节约系统资源）
* 4.0后，广播接收者所在进程如果从来没有被启动过，广播接收者不会生效
* 4.0后，如果系统自动关闭广播接收者所在进程，系统会在广播来时启动进程；但如果广播接收者被用户手动关闭，系统不会在广播来时启动进程，只有用户手动启动时才会再次生效。

###短息拦截过滤
设置短信防火墙优先级，在AndroidManifest.xml中的intent-filter 添加属性 android:priority="1000"，优先级范围为-1000到1000.
>&lt;action android:name="android.provider.Telephony.SMS_RECEIVED" />

```java
@override
public void onReceive(Context context, Intent intent){

	//拿到短信的内容
	//短信内容封装到intent中
	Bundle bundle = intent.getExtras();
	//以pdus为键，取出一个object数组，数组中的每一个元素，都是一条短信
	Object[] objects = (Object[]) bundle.get("pdus");

	//为什么会有多条短信？  短信内容长度有限制，超出长度会分多条短信发送。
	for(Object object : objects){
		SmsMessage sms = SmsMessage.createFromPdu((byte[]) object);
		String phone = sms.getOriginatingAddress();
		String con = sms.getMessageBody();

		if(phone.equal("要拦截的号码")){
			abortBroadcast();//阻止广播向其他程序传播
		}
	}
}
```


###监控SD卡状态
```xml
<receiver android:name = "">
	<intent-filter>
	<action android:name="android.intent.action.MEDIA\_MOUNTED"/>
	<action android:name="android.intent.action.MEDIA\_REMOVED"/>
	<action android:name="android.intent.action.MEDIA\_UNMOUNTED"/>
	<data android:scheme="file"/>
	</intent-filter>
</receiver>
```

```java
@Override
public void onReceive(Context context, Intent intent){
	String action = intent.getAction();
	if("android.intent.action.MEDIA\_MOUNTED".equals(action)){
		//已挂载
	}else if("android.intent.action.MEDIA\_REMOVED".equals(action)){
		//已移除
	}else if("android.intent.action.MEDIA\_UNMOUNTED".equals(action)){
		//未挂载
	}
}
```

###开机自启
```xml
<action android:name="android.provider.Telephony.BOOT_COMPLETED" />

//添加权限
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
```

```java
@Override
public void onReceive(Context context, Intent intent){
    System.out.println("已经开机重启！");
    //实现开机自动启动软件
    Intent it = new Intent(context, MainActivity.class);

    //由于广播接收者没有前台界面，就没有任务栈，所以要创建任务栈，存放启动的Activity
    it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    context.startActivity(it);
}
```

###监控应用的状态(安装、更新、卸载)
```xml
<action android:name="android.intent.action.PACKAGE_ADDED"/>
<action android:name="android.intent.action.PACKAGE_REPLACED"/>
<action android:name="android.intent.action.PACKAGE_REMOVED"/>
<data android:scheme="package"/> 用于携带数据，哪个应用被安装、更新、卸载了
```

```java
@Override
public void onReceive(Context context, Intent intent){
	String action = intent.getAction();
	Uri uri = intent.getData();
	String packageName = uri.toString();

	if("android.intent.action.PACKAGE_ADDED".equals(action)){

	}else if("android.intent.action.PACKAGE_REPLACED".equals(action)){

	}else if("android.intent.action.PACKAGE_REMOVED".equals(action)){

	}
}
```

###发送自定义广播
```java
Intent intent = new Intent();
intent.setAction("cn.annpeter.www"); //广播中的action是自定义的
sendBroadcase(intent);
```

###广播的分类
#####1.无序广播
所有与广播中的action匹配的广播接收者都可以收到这条广播，并且是没有先后顺序之分的，视为同时收到
#####2.有序广播
所有与广播中的action匹配的接收者都可以收到这条广播，但是是由先后顺序对，按照广播接收者的优先级排序，高优先级先收到，低优先级后收到

####有序广播
```java
//发送有序广播
Intent intent = new Intent();
intent.setAction("cn.annpeter.wwww");

//第三个参数，指定广播接收者（被称为最终接收者，最终接收者一定可以收到广播，
//优先级最低，最后收到广播，无论中间是否进行了拦截，并且无需在清单文件中配置action等内容）
sendOrderBroadcast(intent, null, null, null, 0, "参数，比较简单时，直接在这里传参", null);

//接收有序广播
<receiver android:name="cn.annpeter.www.R1">
    <intent-filter android:priority="1000">
        <action android:name="cn.annpeter.www"/>
    </intent-filter>
</receiver>
<receiver android:name="cn.annpeter.www.R2">
    <intent-filter android:priority="800">
        <action android:name="cn.annpeter.www"/>
    </intent-filter>
</receiver>
<receiver android:name="cn.annpeter.www.R3">
    <intent-filter android:priority="600">
        <action android:name="cn.annpeter.www"/>
    </intent-filter>
</receiver>

//接收广播
String text = getResultData();
//修改广播内容 (只能在有序广播中才有效，无序广播无效)
setResultData("这是修改后的广播，低优先级收到！");
```

###代码注册广播接收者

* 清单文件注册广播接收者，广播一旦发出，系统就会去所有清单文件中寻找，哪一个广播接收者的action和广播的action是匹配的，如果找到了，就会把该广播接收者的进程启动起来

* 代码注册，需要使用广播接收者时，执行注册的代码，不需要时，执行解除注册对代码

###特殊的广播接收者

安卓中有一些广播接收者，必须使用代码注册，清单文件注册是无效的（这些广播太频繁了）

1. 屏幕锁屏和解锁

2. 点亮改变

```java
public class ScreenReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if(intent.ACTION_SCREEN_ON.equals(action)){
            System.out.println("屏幕关闭");
        }else if(intent.ACTION_SCREEN_OFF.equals(action)){
            System.out.println("屏幕打开");
        }
    }
}

//注册广播接收者
//创建对象
ScreenReceiver receiver = new ScreenReceiver();
//创建intent-filter对象
IntentFilter filter = new IntentFilter();
filter.addAction(intent.ACTION_SCREEN_ON);
filter.addAction(intent.ACTION_SCREEN_OFF);
//注册广播接收者
registerReceiver(receiver, filter);

//解除注册
unregisterReceiver(receiver);
```


##服务（四大组件之一）
运行于后台的一个组件，用来运行后台代码，服务是没有前台界面的，可以视为没有界面的Activity

###进程优先级
1.Foreground process 拥有一个正在与用户交互的Activity（onResume()方法被调用）的进程
2.Visible process 不在前台，但对用户依然可见，但是没有焦点，如Activity的onPause()方法被调用
3.Service process 通过startService(),开启的进程，杀死后可能会被重启（内存充足）
4.Background process 不可见状态，如Activity的onStop()方法调用后，会变成background process
5.Empty process（通常认为，没有拥有任何活动组件的）

###创建、关闭服务
1. 需要继承自Service类
2. 需要在清单文件application的子节点中声明<service android:name="服务类名全路径"></service>

```java
//首先定义一个MyService的服务类，继承自Service

//显示启动服务
Intent intent = new Intent(this, MyService.class);
startService(intent);

//关闭服务
stopService(intent);
```

###服务的生命周期
```java
//服务被创建过一次就不会再次创建了，但是会再次掉用onStartCommand方法
@Override
public void onCreate(){

}

@Override
public int onStartCommand( Intent intent, int flags, int startId){

    return super.OnStartCommand(intent, flags, startId);
}

@Override
public void onDestroy(){

}
```


###电话录音机
* 空闲状态
* 响铃状态
* 摘机状态

```java
TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);

//listen可以监听很多事件，第二个参数用于指明具体是什么事件
tm.listen(new RecordLisener(), PhoneStateListener.LISTEN_CALL_STATE);

class RecordLisener extends PhoneStateListener{
    @Override
    public void onCallStateChanged(int state, String incomingNumber) {
        super.onCallStateChanged(state, incomingNumber);

        if(state == TelephonyManager.CALL_STATE_OFFHOOK){
            mediaRecorder.start();
            System.out.println("开始录音！");
        }else if(state == TelephonyManager.CALL_STATE_RINGING){
            mediaRecorder = new MediaRecorder();
            mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
            mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
            mediaRecorder.setOutputFile(getFilesDir()+"/recorder.3gp");
            mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
            try {
                mediaRecorder.prepare();
            } catch (IOException e) {
                Log.e("LOG_TAG", "prepare() failed");
            }
            System.out.println("电话来了，已经准备好了录音");
        }else if(state == TelephonyManager.CALL_STATE_IDLE){
            if(mediaRecorder != null){
                mediaRecorder.stop();
                mediaRecorder.release();
                mediaRecorder = null;
                System.out.println("录音已经完毕");
            }
        }
    }
}
```

###服务的开启方式
* startService--stopService  //涉及到的方法onCreate、onStartCommand、onDestroy
  * 该方法启动的是服务进程
  * Activity一旦启动服务，服务就跟Activity没有关系了
* bindService--unBindService //涉及到的方法onBind、onUnbind
  * 该方法启动的不是服务进程
  * Activity与服务建立连接，Activity一旦死亡，服务也会死亡
  * 安卓通过error触发unBindService，所以在此时报出的错误，并不会让程序崩溃
  * 绑定只能绑定一次，重复解绑会崩溃

 **bindService这种方式可用于在Activity中调用Service中的方法，通过中间人调用**

```java
//创建Service类
public class ChuZhangService extends Service {

    //创建中间人类
    class ZhouMi extends Binder{
        public void qianXian() {
            banZheng();
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO Auto-generated method stub
        return new ZhouMi();
    }

    public void banZheng(){
        System.out.println("处长办证！");
    }
}

ZhouMi zm = null;
//在Activity中绑定Service，最好在onCreate中绑定，否则可能照成中间人没有初始化成功而失败
Intent it = new Intent(this, ChuZhangService.class);
bindService(it, new MyConn(), BIND_AUTO_CREATE);


//调用处调用Service中的方法，通过中间人
zm.qianXian();

class MyConn implements ServiceConnection{

    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        // TODO Auto-generated method stub
        //初始化中间人
        zm = (ZhouMi)service;
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        // TODO Auto-generated method stub

    }

}

//注意优化
//中间人周秘属于Service，Service可能有一些私有的方法交给周秘做，不想其他人访问到，我们可以定义一个对公接口，
//周秘实现这个接口，在Activity中获得这个接口，访问中间人方法，从而访问到Service中的方法
```

###服务的混合调用
> 先开始、再绑定、先解绑、再停止

###启动远程服务
####服务的分类
* 本地服务： 指的是服务和启动服务的activity在同一个进程中
* 远程服务： 指的事服务和启动服务的activity在不同的进程中

```java
//启动远程服务
Intent intent = new Intent();
intent.setAction("注册的远程服务的类名");
startService(intent);
```
####AIDL(Android interface definition language)
访问远程服务中的远程方法

#####项目一、服务端
```java
//定义外部访问接口 RInterface.aidl
interface RInterface {
    void play();
    void stop();
}

//定义远程服务 RService.java
public class RService extends Service {

    //Stub继承了Binder并实现了RInterface中的接口函数
    class RControl extends Stub{
        @Override
        public void play() throws RemoteException {
            RService.this.play();
        }

        @Override
        public void stop() throws RemoteException {
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return new RControl();
    }

    public void play(){
        System.out.println("AnnPeter");
    }
}

//清单文件中注册Service
<service android:name=".RService">
    <intent-filter >
        <action android:name="com.example.fun.RService"></action>
    </intent-filter>
</service>
```

#####项目二、客户端
```java
//在项目二中创建一个文件 RInterface.aidl，文件的包名必须和服务端的包名是一样的


//客户端Activity调用服务接口
public class MainActivity extends Activity {

    RInterface ri = null;
    MyConn myConn = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Intent intent = new Intent();
        intent.setAction("com.example.fun.RService");
        intent.setPackage("com.example.fun");
        myConn = new MyConn();
        bindService(intent, myConn, BIND_AUTO_CREATE);
    }

    public void click(View v){
        try {
            ri.play();
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    class MyConn implements ServiceConnection{

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            ri = Stub.asInterface(service);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    }
}
```


##样式和主题
###样式在styles.xml文件中定义

```xml
<style name="styleName">
    <item name="android:textSize">22sp</item>
    <item name="android:textColor">#00ff00</item>
    ...
</style>

<style name="styleName1" parent="styleName">  //继承自styleName样式
    <item name="android:textSize">30sp</item>
    ...
</style>

//继承自styleName样式，在样式表中引用时使用"@style/styleName.styleName2"
<style name="styleName.styleName2">
    <item name="android:textSize">40sp</item>
    ...
</style>
```
**在代码中设置主题（隐藏Title，只会对本Activity生效：requestWindowFeature(Window.FEATURE_NO_TITLE)）**

###主题，和样式定义方式是一样的，主题一般用于Activity和Application，样式一般用于View控件上


##多媒体编程
包括文本、图片、音频、视频

###图片

* 图片在计算机中大小的计算：图片的总大小＝图片的总像素＊每个像素占用的大小

* 单色位图：只能表示2种颜色，使用两个数字：0和1，使用一个长度为1的二进制数字就可以表示了，每个像素占用1/8个字节

* 16色位图：只能表示16种颜色
	* 需要16个数字：0-15，0000-1111
	* 使用一个长度为4的二进制数组就可以表示了
	* 每个像素占用1/2个字节

* 256色位图：能表示256种颜色
	* 需要256个数字：0-255，   0000 0000 － 1111 1111
	* 使用一个长度为8的二进制数字
	* 每个像素占用1个字节

* 24位位图：
	* 每个像素占用24位，也就是3个字节，所以叫24位位图
	* R：0-255，需要一个长度为8的二进制数字，占用1个字节
	* G：0-255，需要一个长度为8的二进制数字，占用1个字节
	* B：0-255，需要一个长度为8的二进制数字，占用1个字节


###加载大图片
```java
ImageView iv = (ImageView) findViewById(R.id.iv);
Options op = new Options();
//设置先不加载像素内容，只加载边界信息，以获取图片大小
op.inJustDecodeBounds = true;
Bitmap bm = BitmapFactory.decodeFile(Environment.getExternalStorageDirectory()+"/a.jpg", op);

//获取图片大小和屏幕大小，计算缩放比例
int imgW = op.outWidth;
int imgH = op.outHeight;

Display display = getWindowManager().getDefaultDisplay();
int sW = display.getWidth();
int sH = display.getHeight();

int scale = 1;
int scaleW = imgW / sW;
int scaleH = imgH / sH;

if(scaleW >= scaleH && scaleW >= 1){
    scale = scaleW;
}else if(scaleW < scaleH && scaleW >= 1){
    scale = scaleH;
}


op.inSampleSize = scale;
//设置回加载像素模式，否则bm为null
op.inJustDecodeBounds = false;
bm = BitmapFactory.decodeFile(Environment.getExternalStorageDirectory()+"/a.jpg", op);
iv.setImageBitmap(bm);

```

###创建图片副本
#####在内存中创建一个图片的拷贝, BitmapFactory.decodeFile()获取的图片是只读的，不能进行修改
```java
//1.在内存中创建一个与原图一样大小的Bitmap对象，创建与原图大小一致的白纸
Bitmap bitmap = Bitmap.createBitmap(bm.getWidth(), bm.getHeight(), bm.getConfig());

//2.创建画笔对象
Paint paint = new Paint();

//3.创建画板对象，把白纸铺在画板上
Canvas canvas = new Canvas(bitmap);

//4.开始作画，把原图的内容绘制在白纸上
Matrix mt = new Matrix();

//效果一
//以中心点缩放0.5倍
//mt.setScale(0.5f, 0.5f, bm.getWidth()/2, bm.getHeight()/2);

//效果二
//镜面效果
//mt.setScale(-1, 1);
//mt.postTranslate(bm.getWidth(), 0); //由于使用了两个效果，所以第二个使用post

canvas.drawBitmap(bm, mt, paint);

iv.setImageBitmap(bitmap);

```

###绘图板
* SD卡每次准备的时候，系统其实是遍历SD卡所有文件，系统会把所有的媒体文件，都在MediaStore数据库中生成一个索引，数据库中保存了文件的文件名、路径、大小、长度和艺术家
* 图库、音乐、视屏程序每次启动时，其实不会去遍历SD卡寻找媒体文件，而是直接从MediaStore数据库中读取多媒体文件，通过库中的索引找到对应的多媒体文件后，把文件显示在界面上

```java
final ImageView iv = (ImageView) findViewById(R.id.iv);

Bitmap bitmapSrc = BitmapFactory.decodeResource(getResources(), R.drawable.a);
final Bitmap bitmapCopy = Bitmap.createBitmap(bitmapSrc.getWidth(),
						bitmapSrc.getHeight(), bitmapSrc.getConfig());

final Paint paint = new Paint();
paint.setStrokeWidth(2);
final Canvas canvas = new Canvas(bitmapCopy);
canvas.drawBitmap(bitmapSrc, new Matrix(), paint);

iv.setOnTouchListener(new OnTouchListener() {

    float startX = 0;
    float startY = 0;

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        int action = event.getAction();

        float x = event.getX();
        float y = event.getY();

        switch (action) {
        case MotionEvent.ACTION_DOWN:
            startX = x;
            startY = y;
            break;
        case MotionEvent.ACTION_MOVE:
            canvas.drawLine(startX, startY, x, y, paint);
            iv.setImageBitmap(bitmapCopy);
            startX = x;
            startY = y;
            break;
        case MotionEvent.ACTION_UP:
            //保存图片
            File file = new File(Environment.getExternalStorageDirectory()+"/a.png");
            FileOutputStream fos = null;
            try {
                fos = new FileOutputStream(file);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
            bitmapCopy.compress(CompressFormat.PNG, 100, fos);

            //发送SD卡就绪广播，让系统遍历SD卡
            Intent mediaScanIntent = null;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
                Uri contentUri = Uri.fromFile(file); //out is your output file
                mediaScanIntent.setData(contentUri);
                sendBroadcast(mediaScanIntent);
            } else {
                mediaScanIntent = new Intent(Intent.ACTION_MEDIA_MOUNTED);
                mediaScanIntent.setData(Uri.fromFile(Environment.getExternalStorageDirectory()));
                sendBroadcast(mediaScanIntent);
            }
            break;
        }
        return true;
    }
});

```

###音乐播放器
```java
public class MusicService extends Service{

    MediaPlayer mediaPlayer = null;
    Timer timer = null;

    //中间人处理
    class MusicControler extends Binder implements MusicInterface{

        @Override
        public void play() {
            MusicService.this.play();
        }

        @Override
        public void stop() {
            MusicService.this.stop();
        }

        @Override
        public void pause() {
            MusicService.this.pause();
        }

        @Override
        public void seekTo(int msec) {
            MusicService.this.seekTo(msec);
        }
    }

    public void play(){
        if(mediaPlayer != null){
            mediaPlayer.start();
        }else{
            try {
                mediaPlayer = new MediaPlayer();
                mediaPlayer.reset();

                //方式一：播放本地音乐
                mediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+
                                            "/Mine.mp3");
                mediaPlayer.prepare();
                mediaPlayer.start();

                //方式二：播放网路音乐
                //mediaPlayer.setDataSource("http://192.168.1.109/musics/Mine.mp3");
                //mediaPlayer.prepareAsync();
                //mediaPlayer.setOnPreparedListener(new OnPreparedListener() {
                //  @Override
                //  public void onPrepared(MediaPlayer mp) {
                //  mediaPlayer.start();
                //  }
                //});

                addTimer();

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void addTimer(){
        final int totalTime = mediaPlayer.getDuration();

        timer =  new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                Handler handler = MainActivity.handler;

                int currentPos = mediaPlayer.getCurrentPosition();
                Bundle bundle = new Bundle();
                bundle.putInt("totalTime", totalTime);
                bundle.putInt("currentPos", currentPos);
                Message msg = new Message();
                msg.setData(bundle);
                handler.sendMessage(msg);
            }
        }, 1000, 1000);
    }

    private void seekTo(int msec) {
        mediaPlayer.seekTo(msec);
    }

    public void stop() {
        if(mediaPlayer != null){
            mediaPlayer.stop();
            mediaPlayer.release();
            mediaPlayer = null;
            timer.cancel();
        }
    }

    public void pause(){
        if(mediaPlayer != null){
            mediaPlayer.pause();
        }
    }

    @Override
    public void onCreate() {
        // TODO Auto-generated method stub
        super.onCreate();
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO Auto-generated method stub
        return new MusicControler();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        mediaPlayer.stop();
        mediaPlayer.release();
        mediaPlayer = null;
        timer.cancel();
    }
}

```

![MediaPlayer调用示意图](/upload/2015/OCT/20/imgs/1445312355.png)


###视频处理
####SurfaceView
* 双缓冲技术
* 重量级组件
* 只要不可见，就不会创建；可见时，才会创建。

```java
public class MainActivity extends Activity {

    SurfaceView sv = null;
    MediaPlayer mp = null;
    int currentPos = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        sv = (SurfaceView) findViewById(R.id.sv);
        final SurfaceHolder sh = sv.getHolder();

        sh.addCallback(new Callback() {

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {

                //因为SurfaceView不可见，就会被销毁，所以mp也应当销毁重建
                if(mp != null){
                    currentPos = mp.getCurrentPosition();
                    mp.stop();
                    mp.release();
                    mp = null;
                }
            }

            @Override
            public void surfaceCreated(SurfaceHolder holder) {

                if(mp == null){
                    mp = new MediaPlayer();
                    mp.reset();
                    try {
                        mp.setDataSource("sdcard/Download/3.mp4");
                        mp.setDisplay(sh);
                        mp.prepare();
                        mp.seekTo(currentPos);
                        mp.start();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {

            }
        });
    }
}

```

####VideoView
```java
VideoView vv = (VideoView)findViewById(R.id.vv);

vv.setVideoPath("sdcard/2.mp4");
vv.start();

```

####FFMPEG
开源免费的音视频编解码器

####Vitamio
* 封装了FFMPEG的视频播放框架
* 对外提供的API全部都是javaAPI

###拍照摄像使用
```java
public void takePhoto(View v){
    Intent intent = new Intent();
    intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);
    intent.putExtra(MediaStore.EXTRA_OUTPUT,Uri.fromFile(new File(Environment.getExternalStorageDirectory(), "1.jpg")));
    startActivityForResult(intent, 0);
}


public void takeVedio(View v){
    Intent intent = new Intent();
    intent.setAction(MediaStore.ACTION_VIDEO_CAPTURE);
    intent.putExtra(MediaStore.EXTRA_OUTPUT,Uri.fromFile(new File(Environment.getExternalStorageDirectory(), "1.3gp")));
    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1);
    startActivityForResult(intent, 10);
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);

    if(requestCode == 0){
        Toast.makeText(this, "拍照成功", 0).show();
    }else if(requestCode == 10){
        Toast.makeText(this, "摄像成功", 0).show();
    }
}

```



##内容提供者（四大组件之一）
把数据暴露给其他应用，通常，是把私有数据库中的数据暴露给其它应用
#####自定义内容提供者
```java
//定义数据库辅助类
public class DBOpenHelper extends SQLiteOpenHelper {

    public DBOpenHelper(Context context) {
        super(context, "peopel.db", null, 1);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL("create table people(_id integer primary key autoincrement, name char(10), phone char(11))");
        db.execSQL("create table teacher(_id integer primary key autoincrement, name char(10)");
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    }

}


//创建自定义内容提供者，重写内容提供者方法
public class PeoplerProvider extends ContentProvider{
    DBOpenHelper dbOpenHelper = null;
    SQLiteDatabase db = null;

    @Override
    public boolean onCreate() {
        dbOpenHelper = new DBOpenHelper(getContext());
        db = dbOpenHelper.getWritableDatabase();
        return false;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        return db.query("people", projection, selection, selectionArgs, null, null, sortOrder, null);
    }

    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        db.insertOrThrow("people", null, values);
        return uri;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return db.delete("people", selection, selectionArgs);
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return db.update("people", values, selection, selectionArgs);
    }

}

//在主配置文件中声明内容提供者
<provider
    android:name="com.example.contentprovider.provider.PeoplerProvider"
    android:authorities="com.example.contentprovider.provider.PeoplerProvider"
    android:exported="true">
</provider>

```

#####访问自定义内容提供者
```java
public class MainActivity extends Activity {

    Uri uri = null;
    ContentResolver cr = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        uri = Uri.parse("content://com.example.contentprovider.provider.PeoplerProvider");
        //通过Uri传递表名参数
        //uri = Uri.parse("content://com.example.contentprovider.provider.PeoplerProvider/people");
        cr = getContentResolver();
    }

    public void insert(View v){
        ContentValues values = new ContentValues();
        values.put("name", "Peter");
        values.put("phone", "123456");
        cr.insert(uri, values);
    }

    public void delete(View v){
        cr.delete(uri, "name=?", new String[]{"AA"});
    }

    public void updata(View v){
        ContentValues values = new ContentValues();
        values.put("name", "AA");
        cr.update(uri, values, "name=?", new String[]{"Peter"});
    }

    public void select(View v){
        Cursor cursor = cr.query(uri, null , null, null, null);

        while(cursor.moveToNext()){
            String name = cursor.getString(cursor.getColumnIndex("name"));
            String phone = cursor.getString(cursor.getColumnIndex("phone"));

            System.out.println(name + "    " + phone);
        }
    }
}

```

####使用Uri匹配器判断携带的路径（表名）
```java
static UriMatcher um = new UriMatcher(UriMatcher.NO_MATCH);
static{
    //content://com.example.contentprovider.provider.PeoplerProvider/people
    um.addURI("com.example.contentprovider.provider.PeoplerProvider", "people", 1);
    //content://com.example.contentprovider.provider.PeoplerProvider/teacher
    um.addURI("com.example.contentprovider.provider.PeoplerProvider", "teacher", 2);
    //content://com.example.contentprovider.provider.PeoplerProvider/teacher/#
    um.addURI("com.example.contentprovider.provider.PeoplerProvider/#", "teacher", 2);
}



//调用的时候
//Uri uri = Uri.parse("content://com.example.contentprovider.provider.PeoplerProvider/people/123");
//cr.insert(uri, values);
@Override
public Uri insert(Uri uri, ContentValues values){
    //使用uri匹配器匹配传入的uri
    if(um.match(uri) == 1){
        db.insert("people", null, values);
    }else if(um.match("teacher") == 2){
        db.insert("teacher", null, values);
    }else if(um.match("teacher") == 3){
        //获取uri末尾携带的数字
        //long id = ContentUris.parseId(uri);
        db.insert("teacher", null, values);
    }else{
        throw new IllegalArgumentException("error args");
    }
    return uri;
}

```

###短信数据库

#####sms表
* body:短信内容
* date:短信时间
* address:对方号码
* type:发送还是接收

```java
public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void getMsg(View v){
        ContentResolver cr = getContentResolver();
        Cursor cursor = cr.query(Uri.parse("content://sms"),
						new String[]{"address", "date", "body", "type"}, null, null, null);
        while(cursor.moveToNext()){
            String address = cursor.getString(0);
            String date = cursor.getString(1);
            String body = cursor.getString(2);
            String type = cursor.getString(3);

            System.out.println(address + "  " + date + "   " + body + "    " + type);
        }

    }
}

//主配文件中添加权限
<uses-permission android:name="android.permission.READ_SMS"/>

```

###联系人数据库
* raw_contacts表
 * contact_id: 联系人id
* data表: 存放联系人的详细信息，每行数据是单独的一条联系人的信息
 * data1: 联系人的具体信息内容
 *  raw_contact_id: 该行信息属于哪一个联系人
 *  mimetype_id: 该行信息属于什么类型
* mimetype表: mimetype_id对应的类型的字符串

###内容观察者
```java
public class MainActivity extends Activity{

    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //注册一个内容观察者，监听短信数据库内容的改变
        ContentResolver cr = getContentResolver();

        //uri：监听哪一个uri上的内容提供者的通知
        //notifyForDescendents：如果是true，那么只要以content:
		//sms开头的uri的数据改变都能收到通知；否则必须精确匹配
        cr.registerContentObserver(Uri.parse("content://sms"), true,
									new MyObserver(new Handler));
    }

    class MyObserver extends ContentObserver{

        public MyObserver(Handler handler){
            super(handler);
        }

        //收到数据改变通知，此方法调用
        @Override
        public void onChange(boolean selfChange){
            super.onChange(selfChange);
            System.out.println("短信数据库改变");
        }
    }
}

```

####在自定义内容提供者中发送内容观察者通知
```java
//在数据改变时添加代码
getContext().getContentResolver().notifyChange(uri, null);

```


##Fragment
* 布局文件，Fragment必须放在帧布局中
* Fragment中的组件的id最好和Activity中组件的id不一样，不然在组件中调用Activity中的方法时，该方法中又同时调用了find ViewById()这一方法，那么优先在fragment中寻找，而不会在Activity中去寻找。

```java
//定义Fragment01类继承自Fragment类，重写onCreateView方法
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

    return inflater.inflate(R.layout.fragment01, null);
}


//在Activity中显示Fragment01返回的View
Fragment01 f1 = new Fragment01();
//获取Fragment管理器
FragmentManager fm = getFragmentManager();
//打开事务
FragmentTransaction ft = fm.beginTransaction();
//把内容显示在帧布局中
ft.replace(R.id.fl, f1);
//提交事务
ft.commit();

```

###Fragment生命周期方法
* fragment之间切换的时候，先销毁旧的，然后创建新的。
* fragment和activity的方法是绑定的



##帧动画FrameAnimation(Drawable Animation)
1. 现在资源文件res/drawable/中定义动画文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<animation-list
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="false" >
    <item android:drawable="@drawable/paoku00001" android:duration="200" />
    <item android:drawable="@drawable/paoku00002" android:duration="200" />
    <item android:drawable="@drawable/paoku00003" android:duration="200" />
    <item android:drawable="@drawable/paoku00004" android:duration="200" />

    <item android:drawable="@drawable/paoku00005" android:duration="200" />
    <item android:drawable="@drawable/paoku00006" android:duration="200" />
    <item android:drawable="@drawable/paoku00007" android:duration="200" />
    <item android:drawable="@drawable/paoku00008" android:duration="200" />

    <item android:drawable="@drawable/paoku00009" android:duration="200" />
    <item android:drawable="@drawable/paoku00010" android:duration="200" />
    <item android:drawable="@drawable/paoku00011" android:duration="200" />
    <item android:drawable="@drawable/paoku00012" android:duration="200" />
</animation-list>

```

2. 开启动画播放

```java
ImageView iv = (ImageView)findViewById(R.id.imageView1);
iv.setBackgroundResource(R.drawable.animation);
AnimationDrawable ad = (AnimationDrawable) iv.getBackground();
ad.start();

```

###补间动画
####位移动画
```java
ImageView iv = (ImageView)findViewById(R.id.iv);

TranslateAnimation ta = new TranslateAnimation(10, 10, 100, 100);
ta.setDuration(2000);
iv.startAnimation(ta);

```

####缩放动画
```java
ImageView iv = (ImageView)findViewById(R.id.iv);
ScaleAnimation sa = new ScaleAnimation(0.5f, 2, 0.1f, 3);
ta.setDuration(2000);
//填充结束位置
sa.setFillAfter(true);
iv.startAnimation(sa);

```

####透明度
```java
ImageView iv = (ImageView)findViewById(R.id.iv);
AlphaAnimation aa = new AlphaAnimation(0, 0.5f);
ta.setDuration(2000);
iv.startAnimation(aa);

```

####旋转动画
```java
ImageView iv = (ImageView)findViewById(R.id.iv);
RotateAnimation ra = new RotateAnimation(20, 180, iv.getWidth() /2, iv.getHeight() / 2);
ta.setDuration(2000);
iv.startAnimation(aa);

```

####多种动画一起播放
```java
Animation set = new AnimationSet(false);
set.addAnimation(); //添加各种动画即可
iv.startAnimation(set);

```

***补间动画只是改变了在屏幕上的绘制效果，但该Object还是在原来等位置
而属性动画，就把Object的位置也改变了***

###属性动画
```java
//target:动画作用于哪个组件
//具有set、get方法的就是属性
ObjectAnimator oa = ObjectAnimator.ofFloat(target, propertyName, values);


//多个属性一起作用
AnimatorSet set = new AnimatiorSet();
set.playSquetially(); //顺序作用
set.playTogether();   //一起作用

//还可以用xml文件定义属性动画
//在res/animator文件夹下创建动画xml
Animator at = AnimatorInflater.loadAnimator(this, R.animator.objanimator);
at.setTarget(target);
at.start();

```



##JNI(java native interface)
####工具
* NDK: native development kit   开发jni必备，模拟其它平台特性来编译的工具
* CDT: c/c++ development tools  高亮显示C语言工具等
* cygwin: 一个模拟器，可以在windows下运行Linux指令

####NDK目录结构
* docs:帮助文档
* build/tools:Linux的批处理文件
* platforms:编译c代码需要使用的头文件和类库
* prebuild:预编译要使用的二进制文件
* toolchains:工具链
* ndk-build.cmd:编译打包c代码的指令

###使用jni
1. 在项目根目录下创建jni文件夹
2. 在jni文件中创建一个c文件
3. 在java代码中，创建一个本地方法helloFromC
    public native String helloFromC();
4. 在jni中定义函数实现这个方法

```cpp
jstring java_com_example_ndkhellloworld_helloFromC(JNIEnv* env, jobject thiz){
	char* arr = "hello from c";

	jstring jstr = (*env)->NewStringUTF(env, arr);
	return jstr;
}

```


5. 在jni中创建Android.mk文件
6. 在c文件中添加<jni.h>头文件
7. 在jni文件夹下执行ndk-build指令
```java
static{
	//加载动态库
	System.loadLibrary("fill");
}

```

###支持x86架构
在Application.mk中添加 APP_ABI := armeabi armeabi-v7a x86

###支持全平台
在Application.mk中添加 APP_ABI := all

###javah
* 1.7: 在src目录下执行javah 包名.类名
* 1.6: 在bin/classes目录下执行javah 包名.类名

###自动化完成
* 点击项目右键Android Tools->Add Native Support
* 关联NDK源码,项目右键Properties->C/C++ General->Paths and Symbals->Add->File System (导入NDK中platform下对应版本的include文件)
* 注意使用c还是使用c++，修改支持平台
* 在java代码中创建本地方法，然后使用javah生成对应c函数头

###JNI常用方法

####java字符串转c字符串
```cpp
char* Jstring2CStr(JNIEnv* env, jstring jstr)
{
     char* rtn = NULL;
     jclass clsstring = (*env)->FindClass(env,"java/lang/String");
     jstring strencode = *env)->NewStringUTF(env,"GB2312");
     jmethodID mid = (*env)->GetMethodID(env,clsstring, "getBytes", "(Ljava/lang/String;)[B");

     // String .getByte("GB2312");
     jbyteArray barr= (jbyteArray)(*env)->CallObjectMethod(env,jstr,mid,strencode);
     jsize alen = (*env)->GetArrayLength(env,barr);
     jbyte* ba = (*env)->GetByteArrayElements(env,barr,JNI_FALSE);
     if(alen > 0)
     {
      rtn = (char*)malloc(alen+1);  //"\0"
      memcpy(rtn,ba,alen);
      rtn[alen]=0;
     }
     (*env)->ReleaseByteArrayElements(env,barr,ba,0);
     return rtn;
}

```
####获取java数组长度
```cpp
int len = (*env)->GetArrayLength(env, arr);
int* arrp = (*env)->GetIntArrayElements(env, arr, 0);

```


###C调用Java方法
```cpp
//打印Log日志
#include <android/log.h>
#incluce LOG_TAG "System.out"
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) //打印debug信息
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)  //打印info信息
//在Android.mk中添加LOCAL_LDLIBS += -llog


//Java反射
//首先定义一个Dialog类，类中有一个show方法，参数为string类型
//1.拿到类的字节码
Class clazz = Demo.class.getClassLoader("Dialog");
//2.拿到方法
Method method = clazz.getDeclaredMethod("show", String.class);
//3.调用方法
method.invoke(clazz.newInstance(), "这里是实参");


//C调用Java的反射
jclass clazz = (*env)->FindClass(env, "com/example/ccalljava/MainActivity");
jmethodID mid = (*env)->GetMethodID(env, clazz, "方法名", "方法签名"); //使用javap获取方法签名
//获取签名做法，到项目的classes目录中，使用(javap -s 包名.类名)即可获取签名

//这里参数使用了中文，注意将.c文件保存为utf-8编码格式保存，否则程序会崩溃
(*env)->CallVoidMethod(env, obj, mid, (*env)->NewStringUTF(env, "这里是实参"));

```

###自定义简单控件显示锅炉压力
```java
public class MainActivity extends Activity {

    MyView bar = null;

    static{
        System.loadLibrary("fill");
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        bar = (MyView) findViewById(R.id.myView);
    }

    public void start(View v){
        Thread thread = new Thread(){
            @Override
            public void run() {
                super.run();
                startFill();
            }
        };
        thread.start();
    }

    public void stop(View v){
        stopFill();
    }

    public void show(int p){
        bar.setCurr(p);
    }

    public native void startFill();
    public native void stopFill();
}


public class MyView extends View {

    int max;
    int curr;

    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyView(Context context) {
        super(context);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        max = 100;

        Paint paint = new Paint();
        if(curr > 80){
            paint.setColor(new Color().GREEN);
        }else if(curr > 60){
            paint.setColor(new Color().YELLOW);
        }else {
            paint.setColor(new Color().RED);
        }

        canvas.drawRect(10, max-curr+10, 20, max+10, paint);
    }

    public void setCurr(int curr){
        this.curr = curr;
        postInvalidate();
    }
}


#include <jni.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
/*
 * Class:     com_example_fill_MainActivity
 * Method:    startFill
 * Signature: ()V
 */
int isRun = 1;
int i = 0;

JNIEXPORT void JNICALL Java_com_example_fill_MainActivity_startFill
  (JNIEnv * env, jobject obj)
{
    srand(0);
    while(isRun)
    {
        jclass clazz = (*env)->FindClass(env, "com/example/fill/MainActivity");
        jmethodID mid = (*env)->GetMethodID(env, clazz, "show", "(I)V");
        (*env)->CallVoidMethod(env, obj, mid, i++);
        i = i==100? 0:i;
        sleep(1);
    }

}
/*
 * Class:     com_example_fill_MainActivity
 * Method:    stopFill
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_fill_MainActivity_stopFill
(JNIEnv * env, jobject obj)
{
    isRun = 0;
}

```

###把C改造为C++
1. 把c文件后缀名换成cpp
2. Android.mk文件中的hello.c也要换成hello.cpp
3. c++使用的环境变量的结构体，访问了c使用的结构体的函数指针，函数名全部都是一样的，只是参数去掉了结构体的指针
4. 在cpp文件中引用javah生成的头文件

##获取地理位置信息
```java
public class LocationService extends Service {

    public static final int CODE_LOCATION = 1;
    private LocationManager locationManager;
    private LocationListener locationListener;

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();

        locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

        Criteria criteria =  new Criteria();
        criteria.setCostAllowed(true);//设置是否付费，比如使用3g网络
        criteria.setAccuracy(Criteria.ACCURACY_FINE);//设置精确度
        String bestService = locationManager.getBestProvider(criteria, true);

        locationListener = new LocationListener() {

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) {

            }

            @Override
            public void onProviderEnabled(String provider) {

            }

            @Override
            public void onProviderDisabled(String provider) {

            }

            @Override
            public void onLocationChanged(Location location) {
                double longitude = location.getLongitude();
                double latitude = location.getLatitude();

                Bundle bundle = new Bundle();
                bundle.putDouble("longtitude", longitude);
                bundle.putDouble("lativude", latitude);

                Message msg = Message.obtain();
                msg.setData(bundle);
                msg.what = CODE_LOCATION;
                SMSReceiver.handler.sendMessage(msg);

                stopSelf();//停止服务，省电
            }
        };

        locationManager.requestLocationUpdates(bestService, 0, 0, locationListener);
    }

    @Override
    public void onDestroy() {
        locationManager.removeUpdates(locationListener);
        super.onDestroy();
    }
}

```

##锁屏，卸载应用

* 创建一个AdminReceiver，继承自DeviceAdminReceiver

* 在清单文件中声明
```xml
<receiver
    android:name=".AdminReceiver"
    android:description="@string/device_admin_desc"
    android:label="手机安全卫士设备管理"
    android:permission="android.permission.BIND_DEVICE_ADMIN">
    <meta-data android:name="android.app.device_admin"
       android:resource="@xml/device_admin" />
    <intent-filter>
        <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
    </intent-filter>
</receiver>

```

* 在res文件夹下创建文件夹xml，在xml中创建文件device_admin.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<device-admin xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-policies>
        <limit-password />
        <watch-login />
        <reset-password />
        <force-lock />
        <wipe-data />
        <expire-password />
        <encrypted-storage />
        <disable-camera />
        <disable-keyguard-features />
    </uses-policies>
</device-admin>

```

* 创建一个Activity

```java
public class MainActivity extends Activity {

    private ComponentName componentName;
    private DevicePolicyManager devicePolicyManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void active(View v){
        //激活设备管理器
        Intent intent_dev = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);

        componentName = new ComponentName(this, AdminReceiver.class);

        intent_dev.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, componentName);
        intent_dev.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,
                            "激活手机安全卫士管理器，全面为您的手机保驾护航");
        startActivity(intent_dev);
    }

    public void lock(View v){
        devicePolicyManager = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);
        if(devicePolicyManager.isAdminActive(componentName)){
            devicePolicyManager.lockNow();

            //重置密码
            devicePolicyManager.resetPassword("123456", 0);//flag表示禁止其它设备管理器再重置密码
        }else{
            Log.i("log", "设备管理器未激活");
        }

    }

    public void uninstall(View v){
        //取消激活，如果未取消激活，该应用将在用户手机上显示为不可卸载
        devicePolicyManager.removeActiveAdmin(componentName);

        //卸载程序
        Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE);
        intent.addCategory(intent.CATEGORY_DEFAULT);
        intent.setData(Uri.parse("package:"+getPackageName()));
        startActivity(intent);

    }

}

```



